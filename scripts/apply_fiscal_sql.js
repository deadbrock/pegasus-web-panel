// Aplica SQL idempotente para módulo Fiscal (fornecedores, notas_fiscais,
// itens_nota_fiscal, movimentacoes_estoque) e políticas RLS

const { Client, defaults } = require('pg')
defaults.ssl = { rejectUnauthorized: false }

const sql = `
create extension if not exists pgcrypto;

-- Fornecedores
create table if not exists public.fornecedores (
  id uuid primary key default gen_random_uuid(),
  razao_social text not null,
  nome_fantasia text null,
  cpf_cnpj text not null,
  rg_ie text null,
  endereco text null,
  telefone text null,
  email text null,
  ativo boolean not null default true,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);
create unique index if not exists fornecedores_cpf_cnpj_key on public.fornecedores(cpf_cnpj);

-- Notas fiscais
create table if not exists public.notas_fiscais (
  id uuid primary key default gen_random_uuid(),
  numero text not null,
  serie text not null,
  chave_acesso text not null,
  cnpj text not null,
  razao_social text not null,
  fornecedor_id uuid null references public.fornecedores(id) on delete set null,
  data_emissao date not null,
  data_entrada timestamptz null,
  valor_total numeric not null,
  base_icms numeric null,
  valor_icms numeric null,
  valor_ipi numeric null,
  valor_pis numeric null,
  valor_cofins numeric null,
  tipo_operacao text not null check (tipo_operacao in ('entrada','saida')),
  cliente_id uuid null,
  pedido_id uuid null,
  observacoes text null,
  status text not null default 'Pendente' check (status in ('Pendente','Processada','Cancelada','Rejeitada','Ativa')),
  xml_path text null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);
create unique index if not exists notas_fiscais_chave_acesso_key on public.notas_fiscais(chave_acesso);
create index if not exists notas_fiscais_data_idx on public.notas_fiscais(data_emissao desc);

-- Itens de nota fiscal
create table if not exists public.itens_nota_fiscal (
  id uuid primary key default gen_random_uuid(),
  nota_fiscal_id uuid not null references public.notas_fiscais(id) on delete cascade,
  produto_codigo text not null,
  quantidade numeric not null,
  valor_unitario numeric not null,
  valor_total numeric not null,
  cfop text null,
  ncm text null,
  cst_icms text null,
  cst_ipi text null,
  cst_pis text null,
  cst_cofins text null,
  processado boolean not null default false,
  created_at timestamptz not null default now()
);
create index if not exists itens_nf_nf_idx on public.itens_nota_fiscal(nota_fiscal_id);

-- Movimentações de estoque
create table if not exists public.movimentacoes_estoque (
  id bigint generated by default as identity primary key,
  nota_fiscal_id uuid null references public.notas_fiscais(id) on delete set null,
  produto_codigo text not null,
  quantidade numeric not null,
  tipo text not null check (tipo in ('entrada_nota','ajuste','saida')),
  custo_unitario numeric null,
  created_at timestamptz not null default now()
);
create index if not exists mov_estoque_nf_idx on public.movimentacoes_estoque(nota_fiscal_id);

-- Trigger updated_at
create or replace function public.set_updated_at() returns trigger language plpgsql as $$
begin
  new.updated_at = now();
  return new;
end$$;
drop trigger if exists trg_fornecedores_updated_at on public.fornecedores;
create trigger trg_fornecedores_updated_at before update on public.fornecedores
for each row execute function public.set_updated_at();
drop trigger if exists trg_notas_updated_at on public.notas_fiscais;
create trigger trg_notas_updated_at before update on public.notas_fiscais
for each row execute function public.set_updated_at();

-- RLS e políticas (provisórias: leitura e escrita abertas)
alter table public.fornecedores enable row level security;
alter table public.notas_fiscais enable row level security;
alter table public.itens_nota_fiscal enable row level security;
alter table public.movimentacoes_estoque enable row level security;

drop policy if exists fornecedores_select_all on public.fornecedores;
create policy fornecedores_select_all on public.fornecedores for select using (true);
drop policy if exists fornecedores_write_all on public.fornecedores;
create policy fornecedores_write_all on public.fornecedores for all using (true) with check (true);

drop policy if exists nf_select_all on public.notas_fiscais;
create policy nf_select_all on public.notas_fiscais for select using (true);
drop policy if exists nf_write_all on public.notas_fiscais;
create policy nf_write_all on public.notas_fiscais for all using (true) with check (true);

drop policy if exists itens_select_all on public.itens_nota_fiscal;
create policy itens_select_all on public.itens_nota_fiscal for select using (true);
drop policy if exists itens_write_all on public.itens_nota_fiscal;
create policy itens_write_all on public.itens_nota_fiscal for all using (true) with check (true);

drop policy if exists mov_select_all on public.movimentacoes_estoque;
create policy mov_select_all on public.movimentacoes_estoque for select using (true);
drop policy if exists mov_write_all on public.movimentacoes_estoque;
create policy mov_write_all on public.movimentacoes_estoque for all using (true) with check (true);

-- Realtime
do $$
begin
  begin execute 'alter publication supabase_realtime add table public.notas_fiscais'; exception when others then null; end;
  begin execute 'alter publication supabase_realtime add table public.itens_nota_fiscal'; exception when others then null; end;
  begin execute 'alter publication supabase_realtime add table public.fornecedores'; exception when others then null; end;
end$$;
`;

async function main() {
  let conn = process.argv[2]
  if (!conn) {
    console.error('DATABASE_URL não informado')
    process.exit(1)
  }
  conn = conn.replace('sslmode=require', 'sslmode=no-verify')
  const client = new Client({ connectionString: conn, ssl: { rejectUnauthorized: false } })
  await client.connect()
  try {
    await client.query('set statement_timeout = 0;')
    await client.query(sql)
    console.log('SQL fiscal aplicado com sucesso')
  } finally {
    await client.end().catch(() => {})
  }
}

main().catch((e) => {
  console.error('Falha ao aplicar SQL fiscal:', e.message)
  process.exit(1)
})


